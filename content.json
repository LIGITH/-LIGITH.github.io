{"meta":{"title":"踏步向前","subtitle":"博客","description":"亲爱的，世界上只有你","author":"踏步向前","url":"https://github.com/LIGITH"},"pages":[{"title":"友情链接","date":"2017-05-28T15:17:04.000Z","updated":"2017-05-29T07:40:48.111Z","comments":false,"path":"links/index.html","permalink":"https://github.com/LIGITH/links/index.html","excerpt":"","text":"djllhs 简介：俗称的女汉子，拥有一个彪悍的内心，不羁的性格。当然，从外表上看是猜不出来这妹纸是个程序员滴~我的生活理念：生活要充满色彩，充满乐趣，做一个不一样的技术性妹纸"},{"title":"","date":"2017-05-27T09:07:52.620Z","updated":"2017-05-27T09:07:52.620Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/LIGITH/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-05-27T09:07:03.330Z","updated":"2017-05-27T09:07:03.330Z","comments":false,"path":"tags/index.html","permalink":"https://github.com/LIGITH/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"开发体系之运行环境","slug":"开发体系之运行环境","date":"2017-06-07T16:00:00.000Z","updated":"2017-06-08T08:25:38.585Z","comments":true,"path":"运行环境/开发体系之运行环境.html","link":"","permalink":"https://github.com/LIGITH/运行环境/开发体系之运行环境.html","excerpt":"","text":"IaaS、PaaS、SaaS初看到这些术语的时候是一脸的问号，这是什么鬼！怎么中间都有个aa呢，看来还得求助万能的Google。 IaaS（基础设施即服务Infrastructure as a Servic） PaaS（平台即服务Platform-as-a-Service） SaaS（软件即服务Software-as-a-Service） 原来都是一个服务，这样想或许也就简单了，虽然具体的去实现这种服务是相对很复杂的，但目前也不用我们去想如此的太复杂。在如今云计算这样的概念被炒的火热的时候，什么都可以租出了。。在浏览之余，我还看到了一个CaaS，当时就想，这些人这么喜欢缩写就不考虑考虑我们的感受吗。 CaaS(通讯即服务Communications-as-a-Service || 容器即服务Container-as-a-Service) IaaS可以租给你硬件，当然是虚拟的，比如服务器、存储和网络硬件等，运用了镜像或者容器等技术； PaaS可以租给你硬件上一层点的，系统、开发库和部署工具等，例如GAE、BAE、SAE、AWS、AZure和阿里云等，都是一些云服务提供商，它们之间是存在着一些差别得。你只需要按照他们的标准来，支持什么样的编程语言、什么版本、什么数据库这样的，就可以在这些基础上进行开发了，有效的节约了开发成本；CaaS（容器即服务）是属于这部分的； SaaS可以直接租给你已经开发好的软件，你直接掏钱就可以了。","categories":[{"name":"运行环境","slug":"运行环境","permalink":"https://github.com/LIGITH/categories/运行环境/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://github.com/LIGITH/tags/后端/"}]},{"title":"页面中 JS 自动运行","slug":"页面中 JS 自动运行","date":"2017-05-31T16:00:00.000Z","updated":"2017-06-01T03:45:39.823Z","comments":true,"path":"JS-问答/页面中 JS 自动运行.html","link":"","permalink":"https://github.com/LIGITH/JS-问答/页面中 JS 自动运行.html","excerpt":"","text":"JS方法触发最直接的方式是直接在Html的body, frame, frameset, iframe, img, link, script标签里使用onland事件，onload事件会在页面或图像加载完成后立即发生。 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function load(){ alert(&apos;onland&apos;); } function func1(){ alert(&apos;func1&apos;); } &lt;/script&gt; &lt;/head&gt; &lt;body onload=&quot;load();func1()&quot;&gt; &lt;/body&gt; &lt;/html&gt; 支持onland的JavaScript 对象有image, layer, window： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function myfun(){ alert(&quot;window.onload&quot;); } window.onload = myfun;//不要括号 &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 或者script标签里是： &lt;script type=&quot;text/javascript&quot;&gt; window.onload=function(){ func1(); func2(); func3(); } &lt;/script&gt; jQuery方法触发&lt;html&gt; &lt;head&gt; &lt;/head&gt; &lt;script src=&quot;jquery-1.11.0.min.js&quot;&gt;&lt;/script&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; (function ($) { alert(window.document.location.pathname);//当前页面所在路径 }(jQuery)); &lt;/script&gt; &lt;/html&gt; window.onload和(function($){}）的区别1.window.onload方法是在网页中的所有元素完全加载到浏览器后才执行，(function(\\$){})方法只要DOM树就绪就可以操作了，无须等待全部加载完成。(function(\\$){})相比window.onload执行更快，有更好的用户体验。 2.JavaScript中的onload事件一次只能保存对一个函数的引用，它会自动用后面的函数覆盖前面的函数。如果多个Javascript文件都使用window.onload方法就会很麻烦。而(function(\\$){})则会在现有的行为上追加新的行为，这些行为会根据注册的顺序依次执行。","categories":[{"name":"JS-问答","slug":"JS-问答","permalink":"https://github.com/LIGITH/categories/JS-问答/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://github.com/LIGITH/tags/前端/"}]},{"title":"JAVA获取文件路径","slug":"JAVA获取文件路径","date":"2017-05-30T16:00:00.000Z","updated":"2017-05-31T07:01:59.699Z","comments":true,"path":"JAVA-问答/JAVA获取文件路径.html","link":"","permalink":"https://github.com/LIGITH/JAVA-问答/JAVA获取文件路径.html","excerpt":"","text":"JAVA获取文件路径标签： Java 曾经被Java获取文件路径的问题所困扰，在开发测试的时候显示一切正常，而在打包运行的时候出现了无法发现文件位置的情况。从而发现文件资源在开发到部署在WEB服务器上的时候，位置可能存在不相同的情况。 我们在拼接URL路径分隔符的时候使用： File.separator 或者 File.separatorChar 不建议直接拼接”/“或者”\\”作为分隔符,因为系统不同，分隔符会存在不同，不利于以后的移植。 获取当前项目路径的方法System.getProperty(&quot;user.dir&quot;); 该方法与下面的方法返回结果是一样的： File directory = new File(&quot;.&quot;); String path = directory.getCanonicalPath(); 这里的File类还有另一个方法getAbsolutePath来获取文件地址： String path2 = directory.getAbsolutePath(); getCanonicalPath和getAbsolutePath的区别在于getCanonicalPath规范化了路径，它将会移除掉路径中的.和..这样情况的路径，而getAbsolutePath不会。 在File类中还有个获取相对路径的方法，它没有规范化： String path3 = directory.getPath(); 获取Class文件的URL类名.class.getResource(&quot;/&quot;); 类名.class.getResource(&quot;&quot;); 第一个获取的URL是源代码编译后class文件的根目录URL,第二个方法获取的是源代码编译后class文件所在包的URL。在getResource方法中可以指定具体文件名称来确定该文件URL。 获取文件路径方法： 类名.class.getResource(&quot;/&quot;).toURI().getPath(); 类名.class.getResource(&quot;&quot;).toURI().getPath(); 路径中存在中文乱码问题java.net.URLDecoder.decode(path, &quot;utf-8&quot;); 可以尝试使用该方法解决乱码问题。","categories":[{"name":"JAVA-问答","slug":"JAVA-问答","permalink":"https://github.com/LIGITH/categories/JAVA-问答/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://github.com/LIGITH/tags/后端/"}]},{"title":"定时任务","slug":"定时任务","date":"2017-05-30T16:00:00.000Z","updated":"2017-05-31T09:18:35.648Z","comments":true,"path":"JAVA-问答/定时任务.html","link":"","permalink":"https://github.com/LIGITH/JAVA-问答/定时任务.html","excerpt":"","text":"定时任务 在JAVA开发中，有时候我们会做到定时任务的功能，而在JAVA中可以实现此功能的类有Timer类和ScheduledExecutorService类。Timer是基于单线程的，ScheduledExecutorService是基于线程池的。这就意味着Timer同一时间只能有一个任务在执行，前一个任务的延迟或异常都将会影响到之后的任务。所以在Java中最好使用ScheduledExecutorService来替换Timer进行开发。也可以利用第三方包来开发该功能，包括Quartz、JCronTab等。 ScheduledExecutorService计时事件接口类： public interface TimerEvent { public void event(); } 计时事件类： private static Runnable runnable = null; private static ScheduledExecutorService service = null; /** * 计时方法 * @param initialDelay 首次启用时间 * @param period 在 initialDelay 后开始执行，然后在initialDelay+period 后执行 */ public void run(long initialDelay, long period, TimerEvent event) { if (service != null) { service.shutdown(); service = null; } if (runnable != null) { runnable = null; } runnable = new Runnable() { @Override public void run() { event.event(); } }; service = Executors.newSingleThreadScheduledExecutor(); service.scheduleAtFixedRate(runnable, initialDelay, period, TimeUnit.SECONDS); } 上面为ScheduledExecutorService计时方法的实例。ScheduledExecutorService较为常用的两个调度方法为ScheduleAtFixedRate 和 ScheduleWithFixedDelay。 ScheduleAtFixedRate方法： ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) command - 执行线程initialDelay - 初始化延时period - 两次开始执行最小间隔时间unit - 计时单位 ScheduleWithFixedDelay方法： ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) command - 执行线程initialDelay - 初始化延时delay - 前一次执行结束到下一次执行开始的间隔时间unit - 计时单位","categories":[{"name":"JAVA-问答","slug":"JAVA-问答","permalink":"https://github.com/LIGITH/categories/JAVA-问答/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://github.com/LIGITH/tags/后端/"}]},{"title":"我们都在路上","slug":"我们都在路上","date":"2017-05-30T03:11:59.000Z","updated":"2017-05-30T02:54:52.004Z","comments":true,"path":"个人情感/我们都在路上.html","link":"","permalink":"https://github.com/LIGITH/个人情感/我们都在路上.html","excerpt":"","text":"我们都在路上标签： 个人情感 感情或许是上帝给人类最好的礼物了，它让我们每个人都与众不同，也让我们每个人是一个真真的人，孤独的人，我们的世界也因此变得丰富多彩。不过，亲爱的，这个世界上只有你，这句温柔而坚定的话，请你一定要记住，强大莫过于此，只有你才能决定你怎么样度过你的每一天，无论是为家人，为朋友，你都应该不言放弃，如果你放弃了，它自然会让你永远屈服。所以关键不在于你打的多用力，而在于你能承受多重的打击并坚持下去。你能承受多少并坚持下去，这才是一个强者应该做的。","categories":[{"name":"个人情感","slug":"个人情感","permalink":"https://github.com/LIGITH/categories/个人情感/"}],"tags":[{"name":"人文","slug":"人文","permalink":"https://github.com/LIGITH/tags/人文/"}]},{"title":"我的博客诞生","slug":"我的博客诞生","date":"2017-05-28T16:00:00.000Z","updated":"2017-05-29T03:48:49.790Z","comments":true,"path":"个人情感/我的博客诞生.html","link":"","permalink":"https://github.com/LIGITH/个人情感/我的博客诞生.html","excerpt":"","text":"博客诞生标签： 个人情感 很神奇，难过的时候才想起自己，发现自己是不是待在原地太久了，忘记了以前的斗志昂扬，嘿嘿，一切还不晚，不求安稳，只为喜欢。 O(∩_∩)O谢谢你来到我的博客！","categories":[{"name":"个人情感","slug":"个人情感","permalink":"https://github.com/LIGITH/categories/个人情感/"}],"tags":[{"name":"人文","slug":"人文","permalink":"https://github.com/LIGITH/tags/人文/"}]},{"title":"迈入Linux的世界（一）","slug":"迈入Linux的世界（一）","date":"2017-05-28T16:00:00.000Z","updated":"2017-05-30T02:08:24.210Z","comments":true,"path":"Linux/迈入Linux的世界（一）.html","link":"","permalink":"https://github.com/LIGITH/Linux/迈入Linux的世界（一）.html","excerpt":"","text":"Linux简介标签： Linux Linux和Unix平时常常听到你会Linux吗？Unix呢？一直不明白他们之间的区别。只是知道他们名字很像，一些命令是可以共通的。后面知道了linux是免费的，unix是收费，是收费的自然会更稳定、更可靠些，毕竟是有商业公司支持的。其实它们的本质上并不是同一个东西。 最简单的说法就是Linux是一个类Unix内核。说到内核，这里可以解释下，它就是一个电脑程序，用于处理其它软件发出的输入输出的要求，将要求转换为数据处理的指令。那么为什么说Linux是一个类Unix内核呢？是因为linux是由李纳斯.特沃兹以安德鲁.S.塔尼鲍默(Andrew S Tanenbum)按照Unix系统的标准POSIX来开发的。同一个标准，自然是一类东西了。 这里要注意的是linux和unix的命令是区分大小写的。 CentOS7以太网络的配置而我最先接触的一个linux系统是CentOS7，当时是怀揣着好奇心探索着linux的世界。从安装到使用都是自己一步一步的去验证，坑是要走过，才知道为何原来如此。 安装的是CentOS7的mini版，安装过程就略了，嘿嘿，这让我想到了高中看数学答案的时候最不喜欢看到的就是答案：（略）。 安装之后linux是没有网络的，这让初学者很是蛋疼，百度嘛，会用到 [root@centos1 ~]#ifconfig 结果很可能显示： -bash: ifconfig: command not found 很正常，毕竟是mini版的，很多package（软件包）是没有的，也就没有这个命令，linux存放外部命令的路径在： /usr/sbin 可以使用ls命令查看： ls /usr/sbin/ 那我们不用ifconfig这个命令，我们用什么呢，不急我们可以查看命令啊，查看后可以用什么呢，我们可以看到可以用ip这个命令 ip [选项] 操作对象{link|addr|route...} 12345678910111213141516# ip link show # 显示网络接口信息# ip link set eth0 upi # 开启网卡# ip link set eth0 down # 关闭网卡# ip link set eth0 promisc on # 开启网卡的混合模式# ip link set eth0 promisc offi # 关闭网卡的混个模式# ip link set eth0 txqueuelen 1200 # 设置网卡队列长度# ip link set eth0 mtu 1400 # 设置网卡最大传输单元# ip addr show # 显示网卡IP信息# ip addr add 192.168.0.1/24 dev eth0 # 设置eth0网卡IP地址192.168.0.1# ip addr del 192.168.0.1/24 dev eth0 # 删除eth0网卡IP地址# ip route list # 查看路由信息# ip route add 192.168.4.0/24 via 192.168.0.254 dev eth0 # 设置192.168.4.0网段的网关为192.168.0.254,数据走eth0接口# ip route add default via 192.168.0.254 dev eth0 # 设置默认网关为192.168.0.254# ip route del 192.168.4.0/24 # 删除192.168.4.0网段的网关# ip route del default # 删除默认路由 输入ip addr试试： [root@centos1 ~]#ip addr 可以观察到enp2s0这块网卡（这是我的网卡）没有ip地址。既然没有ip地址，那直接去/etc/sysconfig/network-scripts目录中看一下网卡的配置文件吧 [root@centos1 ~]#ls /etc/sysconfig/network-scripts/ 我们可以看到ifcfg-enp2s0这个网卡的配置文件，我们接着查看ifcfg-enp2s0配置信息，使用cat命令：1234567891011121314151617[root@centos1 ~]#cat /etc/sysconfig/network-scripts/ifcfg-enp2s0HWADDR=00:E0:69:01:6A:96TYPE=EthernetBOOTPROTO=dhcpDEFROUTE=yesPEERDNS=yesPEERROUTES=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_PEERDNS=yesIPV6_PEERROUTES=yesIPV6_FAILURE_FATAL=noNAME=enp2s0UUID=5b0a7d76-1602-4e19-aee6-29f57618ca01ONBOOT=no 从上面的配置中我们可以看到虽然BOOTPROTO=dhcp，但是ONBOOT=no，这里用vi将ONBOOT=no改成ONBOOT=yes之后，让其自动获取ip,然后再重启CentOS系统。重启命令： [root@centos1 ~]#shutdown -r 重启之后再使用 ip addr查看，是不是获取到ip地址了呢。当然，这里我阴险的笑了，是可以不用重启，我们可以通过重启网络服务来使网卡配置文件生效： systemctl restart network 固定IP地址固定电脑IP，需要将网卡的配置文件里面的dhcp（动态主机配置协议）注释掉，用#将BOOTPROTO=dhcp注释，并添加一下参数： IPADDR0=172.8.1.211 PREFIX0=24 GATEWAY0=172.8.1.1 DNS1=172.8.1.1 设置之后，我们的IP地址就被固定为172.8.1.211这个IP了。PREFIX0指的是子网掩码的位数；GATEWAY0指的是网关。如果你喜欢用ifconfig命令，你可以安装net-tools组件： [root@centos1 ~]#yum install net-tools 连接无线wifi当然，linux也是可以连接无线的，笔记本通常会用到这样的配置。这需要无线网卡的支持，我们可以通过以下命令查看是否有无线网卡驱动： dmesg | grep firmware 如果您得到类似 SIOCSIFFLAGS: No such file or directory 这样的输出，意味着您得手动加载安装驱动；如果没有输出，则表明系统无线网卡已经存在驱动。则可以进行连接无线的配置：1.查看无线网口： iw dev interface后面即为无线网口号2.激活无线网络接口： ip link set wls1 up 3.查看接口是否激活： ip link show wls1 wls1: mtu 1500 qdisc mq state DOWN mode DORMANT group default qlen 1000 link/ether 00:11:22:33:44:55 brd ff:ff:ff:ff:ff:ff&lt; BROADCAST,MULTICAST,UP,LOWER_UP&gt; 中的UP 表明该接口激活成功，后面的 state DOWN 无关紧要4.查看无线网络连接情况： iw wls1 link 显示是无连接的5.扫描可连接的wifi iw wls1 scan | grep SSID 6.找到你需要的wifi，连接指定的SSID wpa_supplicant -B -i wlp3s0 -c &lt;(wpa_passphrase &quot;ssid&quot; &quot;psk&quot;) 将ssid替换为实际的网络名称，psk替换为无线密码，请保留引号。7.用dhcp获得IP分配： dhclient wlp3s0 8.测试是否成功地从路由器获取了ip ip addr show wls1 无线配置至此完成，您可以通过PING命令测试网络是否连接上。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://github.com/LIGITH/categories/Linux/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://github.com/LIGITH/tags/后端/"}]},{"title":"从外网 SSH 进局域网，反向代理+正向代理解决方案","slug":"利用SSH进局域网","date":"2017-05-28T16:00:00.000Z","updated":"2017-05-29T02:51:51.946Z","comments":true,"path":"SSH/利用SSH进局域网.html","link":"","permalink":"https://github.com/LIGITH/SSH/利用SSH进局域网.html","excerpt":"","text":"标签： SSH 问题描述机器状况 目标从C机器使用访问A 解决方案环境需求：每台服务器都需要SSH客户端；A、B两台机器需要SSH服务器端。通常使用的是OpenSHH。 在Ubuntu上的安装过程为： sudo apt-get install openssl-server 实施步骤：1.建立A机器到B机器的反向代理【A机器上操作】 ssh -fCNR 端口1:localhost:22 usr_b@B.B.B.B 说明：端口1 为 B 机器上端口，用来与 A 机器上的22端口绑定。 eg: ssh -fCNR 10001:localhost:22 root@192.168.1.22 2.建立 B 机器上的正向代理，用作本地转发。做这一步是因为绑定后的 端口只支持本地访问【B 机器上操作】 ssh -fCNL &quot;*:端口2:localhost:端口1” localhost 说明：端口2为本地转发端口，用以和外网通信，并将数据转发到端口1，实现可以从其他机器访问。其中的*表示接受来自任意机器的访问。 eg: ssh -fCNL &quot;*:10007:localhost:10001&quot; localhost 3.现在在 C 机器上可以通过 B 机器 ssh 到 A 机器 ssh -p 端口2 usra@B.B.B.B 参数解释：-f 后台运行-C 允许压缩数据-N 不执行任何命令-R 将端口绑定到远程服务器，反向代理-L 将端口绑定到本地客户端，正向代理","categories":[{"name":"SSH","slug":"SSH","permalink":"https://github.com/LIGITH/categories/SSH/"}],"tags":[{"name":"后端","slug":"后端","permalink":"https://github.com/LIGITH/tags/后端/"}]}]}